<!DOCTYPE html>
<html lang="zh-HK">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>3 ç§’å¹³å‡åˆ†è²ï¼ˆ0 dBæ ¡æº– + è¶…æ¨™æç¤º + å¸¸äº® + åœ–è¡¨ï¼‰</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: -apple-system, system-ui, "Segoe UI", Roboto, "Noto Sans TC", Arial, sans-serif; margin:0; padding:24px; background:#0b0f14; color:#e6eef7; }
    h1 { font-size:20px; margin:0 0 8px; }
    .row { display:flex; gap:12px; margin:12px 0 12px; flex-wrap:wrap; }
    button, select {
      padding:12px 14px; font-size:16px; border-radius:12px; border:none; cursor:pointer;
      background:#1e88e5; color:#fff;
    }
    button.secondary { background:#455a64; }
    button.ghost { background:transparent; border:1px solid #2b3b53; color:#e6eef7; }
    select { background:#121821; border:1px solid #223047; color:#e6eef7; }
    .panel { background:#121821; border:1px solid #223047; border-radius:16px; padding:16px; transition:background 0.3s, border-color 0.3s; }
    .panel.alert { background:#8d6e00; border-color:#ffeb3b; }
    .big { font-size:44px; font-weight:700; letter-spacing:0.5px; }
    .label { opacity:0.8; font-size:14px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
    .hint { font-size:13px; opacity:0.75; margin-top:10px; line-height:1.45; }
    .ok { color:#80cbc4; }
    .warn { color:#ffab91; }
    .bad { color:#ff8a80; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #2b3b53; margin-left:6px; }
    .flash { box-shadow:0 0 0 3px rgba(255,87,34,.45) inset; }
    canvas { display:block; width:100%; height:100px; margin-top:16px; border:1px solid #223047; border-radius:8px; background:#0b0f14; }
  </style>
</head>
<body>
  <h1>ğŸ“¢ 3 ç§’å¹³å‡åˆ†è²ï¼ˆç›¸å°æ ¡æº– 0 dBï¼‰</h1>

  <div class="row">
    <button id="startBtn">é–‹å§‹é‡åº¦</button>
    <button id="calBtn" class="secondary" disabled>é‡æ–°æ ¡æº–ï¼ˆ1 ç§’ï¼‰</button>
    <select id="threshSel" title="è¶…æ¨™æç¤ºé–¾å€¼" disabled>
      <option value="15" selected>æç¤ºï¼š15 dB</option>
      <option value="20">æç¤ºï¼š20 dB</option>
      <option value="25">æç¤ºï¼š25 dB</option>
      <option value="30">æç¤ºï¼š30 dB</option>
    </select>
    <button id="alertToggle" class="ghost" disabled>ğŸ”” æç¤ºå·²é—œ</button>
    <button id="wakeToggle" class="ghost">ğŸ’¡ è¢å¹•å¸¸äº®ï¼šé—œ</button>
  </div>

  <div id="panel" class="panel">
    <div class="label">æœ€è¿‘ 3 ç§’å¹³å‡</div>
    <div id="dbOut" class="big mono">0.0 dB</div>
    <div class="label">
      ç‹€æ…‹ï¼š<span id="status">æœªé–‹å§‹</span>
      <span id="calBadge" class="badge">æœªæ ¡æº–</span>
    </div>
    <div class="label">
      é–¾å€¼ï¼š<span id="threshLabel" class="ok">15 dB</span>
    </div>
  </div>

  <canvas id="dbChart"></canvas>

  <div class="hint">
    â€¢ ç¬¬ä¸€æ¬¡é–‹å§‹æœƒè‡ªå‹•æ ¡æº– 1 ç§’ï¼ŒæŠŠç•¶å‰ç’°å¢ƒå®šç‚º <b>0 dB</b>ã€‚<br/>
    â€¢ ç•¶ä½ æŒ‰ã€ŒğŸ”” æç¤ºå·²é–‹ â†’ æç¤ºå·²é—œã€æ™‚ï¼Œæœƒ **ç«‹å³é‡æ–°æ ¡æº–èƒŒæ™¯éŸ³é‡ç‚º 0 dB** ä¸¦é–‹å§‹ç›£æ§ã€‚<br/>
    â€¢ è‹¥ 3 ç§’å¹³å‡è¶…éæ‰€é¸é–¾å€¼ï¼ˆç›¸å°æ–¼ 0 dBï¼‰æœƒæ’­æ”¾æç¤ºè²ã€èƒŒæ™¯è®Šé»ƒã€ä¸¦åœ¨åœ–è¡¨åæ˜ è®ŠåŒ–ã€‚<br/>
    â€¢ ã€Œè¢å¹•å¸¸äº®ã€éœ€æ‰‹å‹•é–‹å•Ÿï¼›éƒ¨åˆ†ç€è¦½å™¨æˆ–è£ç½®å¯èƒ½ä¸æ”¯æ´ã€‚<br/>
    â€¢ æ‰‹æ©Ÿéº¥å…‹é¢¨ä¸¦éå°ˆæ¥­å„€å™¨ï¼Œè®€æ•¸åƒ…ä¾›ç›¸å°æ¯”è¼ƒèˆ‡æ•™è‚²ç”¨é€”ã€‚
  </div>

  <script>
    const startBtn   = document.getElementById('startBtn');
    const calBtn     = document.getElementById('calBtn');
    const dbOut      = document.getElementById('dbOut');
    const statusEl   = document.getElementById('status');
    const calBadge   = document.getElementById('calBadge');
    const panelEl    = document.getElementById('panel');
    const threshSel  = document.getElementById('threshSel');
    const threshText = document.getElementById('threshLabel');
    const alertToggle= document.getElementById('alertToggle');
    const wakeToggle = document.getElementById('wakeToggle');
    const canvas     = document.getElementById('dbChart');
    const ctx        = canvas.getContext('2d');

    let audioCtx, analyser, source, stream;
    let refPower = null;
    let isMeasuring = false;
    const frameBuf = [];
    const WINDOW_MS = 3000;
    const CAL_MS = 1000;
    let rafId = null;

    let alertEnabled = false;
    let thresholdDb = 15;
    let lastBeepAt = 0;
    const BEEP_COOLDOWN_MS = 2000;

    let wakeLock = null;

    const chartData = [];
    const MAX_DATA_POINTS = 100;

    function toDbRel(power, refPwr) {
      if (!refPwr || power <= 0) return -Infinity;
      return 10 * Math.log10(power / refPwr);
    }

    async function initAudio() {
      stream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
      });
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      source = audioCtx.createMediaStreamSource(stream);
      source.connect(analyser);
    }

    function computeFramePower() {
      const buf = new Uint8Array(analyser.fftSize);
      analyser.getByteTimeDomainData(buf);
      let sumSq = 0;
      for (let i=0; i<buf.length; i++) {
        const v = (buf[i] - 128) / 128;
        sumSq += v * v;
      }
      const rms = Math.sqrt(sumSq / buf.length);
      return rms * rms;
    }

    async function calibrateOneSecond() {
      statusEl.textContent = 'æ ¡æº–ä¸­ï¼ˆ1 ç§’ï¼‰â€¦';
      const tStart = performance.now();
      let acc = 0, n = 0;
      return new Promise(resolve => {
        function tick() {
          const now = performance.now();
          const p = computeFramePower();
          acc += p; n++;
          if (now - tStart >= CAL_MS) {
            const meanP = acc / Math.max(1, n);
            refPower = Math.max(meanP, 1e-12);
            statusEl.textContent = 'å·²æ ¡æº–ï¼š0 dB';
            calBadge.textContent = 'å·²æ ¡æº–';
            resolve();
          } else {
            requestAnimationFrame(tick);
          }
        }
        requestAnimationFrame(tick);
      });
    }

    function setThresholdUI(val) {
      thresholdDb = Number(val);
      threshText.textContent = `${thresholdDb} dB`;
      threshText.classList.remove('ok','warn','bad');
      if (thresholdDb <= 15) threshText.classList.add('warn');
      else                  threshText.classList.add('ok');
    }

    function flashPanel() {
      panelEl.classList.add('flash');
      setTimeout(() => panelEl.classList.remove('flash'), 200);
    }

    function beep() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = 'square';
      osc.frequency.setValueAtTime(1000, now);
      gain.gain.setValueAtTime(0.5, now);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.5);
      osc.connect(gain).connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.6);
    }

    function maybeAlert(db) {
      if (!alertEnabled || !isFinite(db)) return;
      const nowMs = performance.now();
      if (db >= thresholdDb) {
        panelEl.classList.add('alert');
        if ((nowMs - lastBeepAt) > BEEP_COOLDOWN_MS) {
          lastBeepAt = nowMs;
          flashPanel();
          beep();
        }
      } else {
        panelEl.classList.remove('alert');
      }
    }

    function drawChart() {
      const w = canvas.clientWidth;
      const h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      ctx.beginPath();
      ctx.strokeStyle = '#80cbc4';
      ctx.lineWidth = 2;
      const len = chartData.length;
      for (let i=0; i<len; i++) {
        const x = i / (MAX_DATA_POINTS - 1) * w;
        const val = chartData[i];
        const y = h - ((val + 50) / 100 * h); // å‡è¨­ç¯„åœ -50 ~ +50 dB
        if (i === 0) ctx.moveTo(x, y);
        else        ctx.lineTo(x, y);
      }
      ctx.stroke();

      const thrY = h - ((thresholdDb + 50) / 100 * h);
      ctx.beginPath();
      ctx.strokeStyle = '#ffeb3b';
      ctx.setLineDash([4,4]);
      ctx.moveTo(0, thrY);
      ctx.lineTo(w, thrY);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function loop() {
      const now = performance.now();
      const p = computeFramePower();
      frameBuf.push({ t: now, p });
      while (frameBuf.length && (now - frameBuf[0].t) > WINDOW_MS) frameBuf.shift();

      let sum = 0;
      for (const it of frameBuf) sum += it.p;
      const meanP = sum / Math.max(1, frameBuf.length);

      let db = 0.0;
      if (refPower) {
        db = toDbRel(meanP, refPower);
        if (!isFinite(db)) db = 0.0;
      } else {
        db = 0.0;
      }
      dbOut.textContent = `${db.toFixed(1)} dB`;

      chartData.push(db);
      if (chartData.length > MAX_DATA_POINTS) chartData.shift();
      drawChart();

      maybeAlert(db);

      rafId = requestAnimationFrame(loop);
    }

    async function startMeasure() {
      if (isMeasuring) return;
      isMeasuring = true;
      startBtn.disabled = true;
      statusEl.textContent = 'åˆå§‹åŒ–éŸ³è¨Šâ€¦';

      await initAudio();

      calBtn.disabled = false;
      threshSel.disabled = false;
      alertToggle.disabled = false;

      await calibrateOneSecond();

      statusEl.textContent = 'é‡åº¦ä¸­ï¼ˆ3 ç§’å¹³å‡ï¼‰';
      loop();
    }

    async function recalibrate() {
      statusEl.textContent = 'æº–å‚™æ ¡æº–â€¦è«‹ä¿æŒå®‰éœ';
      await new Promise(r => setTimeout(r,300));
      await calibrateOneSecond();
    }

    async function toggleWakeLock() {
      if ('wakeLock' in navigator) {
        try {
          if (!wakeLock) {
            wakeLock = await navigator.wakeLock.request('screen');
            wakeToggle.textContent = 'ğŸ’¡ è¢å¹•å¸¸äº®ï¼šé–‹';
            wakeLock.addEventListener('release', () => {
              wakeToggle.textContent = 'ğŸ’¡ è¢å¹•å¸¸äº®ï¼šé—œ';
              wakeLock = null;
            });
            document.addEventListener('visibilitychange', async () => {
              if (document.visibilityState === 'visible' && !wakeLock) {
                try {
                  wakeLock = await navigator.wakeLock.request('screen');
                  wakeToggle.textContent = 'ğŸ’¡ è¢å¹•å¸¸äº®ï¼šé–‹';
                  wakeLock.addEventListener('release', () => {
                    wakeToggle.textContent = 'ğŸ’¡ è¢å¹•å¸¸äº®ï¼šé—œ';
                    wakeLock = null;
                  });
                } catch {}
              }
            });
          } else {
            await wakeLock.release();
            wakeLock = null;
            wakeToggle.textContent = 'ğŸ’¡ è¢å¹•å¸¸äº®ï¼šé—œ';
          }
        } catch (e) {
          alert('æ­¤ç€è¦½å™¨ä¸æ”¯æ´è¢å¹•å¸¸äº®æˆ–ç›®å‰ç„¡æ³•å•Ÿç”¨ã€‚');
        }
      } else {
        alert('æ­¤ç€è¦½å™¨ä¸æ”¯æ´è¢å¹•å¸¸äº® (Screen Wake Lock API)ã€‚');
      }
    }

    startBtn.addEventListener('click', startMeasure);
    calBtn.addEventListener('click', recalibrate);
    threshSel.addEventListener('change', e => setThresholdUI(e.target.value));
    alertToggle.addEventListener('click', async () => {
      alertEnabled = !alertEnabled;
      alertToggle.textContent = alertEnabled ? 'ğŸ”” æç¤ºå·²é–‹' : 'ğŸ”• æç¤ºå·²é—œ';
      alertToggle.classList.toggle('secondary', alertEnabled);
      if (alertEnabled) {
        await calibrateOneSecond();
      }
    });
    wakeToggle.addEventListener('click', toggleWakeLock);

    setThresholdUI(thresholdDb);
  </script>
</body>
</html>

